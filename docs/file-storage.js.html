<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: file-storage.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: file-storage.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var fs = require('fs');
var path = require('path');
// TODO: Remove mkdirp dependency and force the storage directory to be created before.
var mkdirp = require('mkdirp');

var checkCallBack = require('./utils.js').checkCallBack;
var validateKey = require('./utils.js').validateKey;
var buidFilePath = require('./utils.js').buidFilePath;

/** @module */

/**
 * @typedef {function} Callback
 * @param {Object|null} err The error object if something wrong appened, null otherwhise.
 * @param {string} [data] The value read from the file. For {@link getItem} only.
 */

/**
 * @summary Instantiate a new FileStorage object.
 * @constructor
 * @param {string} directory The directory in which the files will be written.
 */
function FileStorage(directory) {
    if (!(this instanceof FileStorage)) {
        return new FileStorage(directory);
    }

    if (typeof directory !== 'string') {
        throw TypeError('Missing path argument');
    }

    this.directory = directory;
    this.keys = [];

    Object.defineProperty(this, 'length', {
        get: function () { return this.keys.length; }
    });
}

/**
 * @summary Get the key at index.
 * @description
 * The indexes of the keys are arbitraty.
 * They won't change until you set or remove a key.
 * @param {number} index The index at which looking for a key name.
 * @returns {string} The key at index position.
 */
FileStorage.prototype.key = function key(index) {
    if (typeof index !== 'number') {
        throw new TypeError('index must be a number. ' + index + 'given.');
    }

    var isIndexOutOfBounds = index &lt; 0 || index >= this.keys.length;
    return isIndexOutOfBounds ? null : this.keys[index];
}

/**
 * @summary Read the item for the given key.
 * @description
 * First checks if the key exists.
 * If so, reads the content of the file named after the given key.
 * @param {string} key The key to read.
 * @param {module:file-storage~Callback} cb The function to be called when the operation succeed or fail.
 * @returns {void}
 */
FileStorage.prototype.getItem = function getItem(key, cb) {
    cb = checkCallBack(cb);

    var keyValidationResult = validateKey(key, this.keys);
    if (!keyValidationResult.isValid) { return cb(new Error(keyValidationResult.message)); }
    if (!keyValidationResult.isPresent) { return cb(null); }

    var filePath = buidFilePath(this.directory, key);
    fs.readFile(filePath, { encoding: 'utf8' }, cb);
}

/**
 * @summary Write the item's value for the given key.
 * @param {string} key The key under which to write the value.
 * @param {undefined|null|string} value The value to write. Will be converted to a string with `.toString()`.
 * @param {module:file-storage~Callback} cb The function to be called when the operation succeed or fail.
 * @returns {void}
 */
FileStorage.prototype.setItem = function setItem(key, value, cb) {
    cb = checkCallBack(cb);

    var keyValidationResult = validateKey(key, this.keys);
    if (!keyValidationResult.isValid) { return cb(new Error(keyValidationResult.message)); }

    if (value === undefined) { value = 'undefined'; }
    if (value === null) { value = 'null'; }
    value = value.toString();

    var self = this;

    fs.access(this.directory, function (err) {
        if (err !== null) {
            if (err.code === 'ENOENT') {
                mkdirp(self.directory, function (err) {
                    if (err) { cb(err); }
                    else { resume(); }
                });
            } else { cb(err); }
        } else { resume(); }
    });

    function resume() {
        var filePath = buidFilePath(self.directory, key);
        fs.writeFile(filePath, value, { encoding: 'utf8' }, function (err) {
            if (err) {
                err.n = 2;
                return cb(err);
            } else {
                if (self.keys.indexOf(key) === -1) {
                    self.keys.push(key);
                }
                cb(null);
            }
        });
    }
}

/**
 * @summary Deletes the file on the file syste for the given key.
 * @param {string} key The key under which to delete the value.
 * @param {module:file-storage~Callback} cb The function to be called when the operation succeed or fail.
 * @returns {void}
 */
FileStorage.prototype.removeItem = function removeItem(key, cb) {
    cb = checkCallBack(cb);

    var keyValidationResult = validateKey(key, this.keys);
    if (!keyValidationResult.isValid) { return cb(new Error(keyValidationResult.message)); }
    if (!keyValidationResult.isPresent) { return cb(null); }

    var filePath = buidFilePath(this.directory, key);
    var self = this;

    fs.unlink(filePath, function (err) {
        if (err) {
            cb(err);
        } else {
            self.keys.splice(keyValidationResult.atIndex, 1);
            cb(null);
        }
    });
}

/**
 * @summary Remove all the files accessible with {@link module:FileStorage~key}.
 * @description
 * In order to know which key to delete, the clear method does a for each loop on the keys array used internally.
 * Thus, not all files present in the storage directory will be deleted.
 * @returns {void}
 */
FileStorage.prototype.clear = function clear(cb) {
    cb = checkCallBack(cb);

    if (this.keys.length === 0) { return cb(null); }

    var initialKeyCount = this.keys.length;
    var removeItemResultsCount = 0;
    var hasErrorOccurred = false;

    var self = this;

    this.keys.forEach(function (key) {
        self.removeItem(key, function (err) {
            var index = self.keys.indexOf(key);
            if (index !== -1) { self.keys.splice(index); }
            joinCallbacks(err);
        });
    });

    function joinCallbacks(err) {
        if (hasErrorOccurred) { return; }
        if (err) { hasErrorOccurred = true; return cb(err); }
        removeItemResultsCount++;
        if (removeItemResultsCount === initialKeyCount) { return cb(null); }
    }
}

module.exports.FileStorage = FileStorage;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-file-storage.html">file-storage</a></li><li><a href="module-utils.html">utils</a></li></ul><h3>Classes</h3><ul><li><a href="module-file-storage-FileStorage.html">FileStorage</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sun Dec 18 2016 00:44:18 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
